# The Anadromi Project
The Anadromi Project (TAP) is an innovative approach to computer science education. Armed with Python, this revolutionary open source program focuses on teaching the bright leaders of tomorrow necessary tools for **recursion** and **algorithmic thinking**. These skills are applicable and essential to both the computer science field as well as other disciplinaries.

## Table of Contents
1. [Prerequisites](#prerequisites)
2. [Stage 1: Hill Climbing](#stage-1-hill-climbing)   
    * [Linear Search](#linear-search)
    * [Selection Sort](#selection-sort)
    * [Bubble Sort](#bubble-sort)
    * [Time Complexity](#time-complexity)
3. [Stage 2: Gaining Speed](#gaining-speed)
    * [Binary Search](#binary-search)
    * [Merge Sort](#merge-sort)
    * [Quicksort](#quicksort)
4. [Stage 3: At the Top](#stage-3-at-the-top)
    * [Greedy](#greedy)
    * [Binary Search Tree](#binary-search-tree)
    * [Dynamic Programming](#dynamic-programming)

## Prerequisites
Students should have be comfortable the basic concepts of programming: 
* Variables and simple data types
* Loops
* Conditional operators
* Functions

## Stage 1: Hill Climbing
This stage will focus on simple but inefficent algorithms that neatly fuse the basics of programming, preparing the student for more advanced concepts.
### Linear Search
Students will start off with a basic implementation of a linear search, a search algorithm that finds the index of a specific element in a list.

### Selection Sort
This program will use the selection sort algorithm to sort an unordered list.

### Bubble Sort
Another algorithm exercise to practice coding skills.

### Time Complexity
This rather abstract concept is introduced rather early on in order to demonstrate the efficency of the previously learned algorithms. Time complexity provides a nice segway into recursion and answers the question to *why* we need these efficent yet terribly complex algorithms.

## Stage 2: Gaining Speed
This stage focuses on the transition to more complicated algorithms that introduce recursion.

### Binary Search
Binary search is a searching algorithm that works only on ordered lists, though far faster than the previous linear search. The theory behind it is not difficult to understand, but it will introduce the Three Laws of Recursion and feature its application.

### Merge Sort
Merge sort builds on the recursive foundation binary search introduced previously, sorting a list far faster than selection sort and bubble sort by a large margin.

### Quicksort
The most modern of sorting algorithms, quicksort depicts the mastery of recursion and shows readiness to move onto dynamic programming.

## Stage 3: At the Top
Using everything learned from the previous lessons, the student will create different algorithmic solutions to the knapsack problem. This is the capstone project of the program.

### Greedy
Imagine that you have an empty bag which  you must fill with items, each of these items containing an arbitrary value and cost when taken. What would you take? How can you take the *best* choice? This particular implementation will focus on the greedy algorithm, the philosophy of taking what seems to be the most valuable at the moment.

### Binary Search Tree
Rather than greedily taking whatever is most valuable, the binary search tree algorithm will search **all** combinations of items and then decide what is *best*.

### Dynamic Programming
Dynamic programming will build on the binary search tree implementation, improving the efficency of the program.
